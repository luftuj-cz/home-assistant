import { Router } from "express";
import type { Request, Response } from "express";
import type { Logger } from "pino";
import {
  getAppSetting,
  setAppSetting,
  getTimelineEvents,
  upsertTimelineEvent,
  deleteTimelineEvent,
  deleteTimelineEventsByMode,
  getTimelineModes,
  getTimelineMode,
  upsertTimelineMode,
  deleteTimelineMode,
  assignLegacyEventsToUnit,
} from "../services/database";
import {
  TIMELINE_OVERRIDE_KEY,
  HRU_SETTINGS_KEY,
  type TimelineMode,
  type TimelineOverride,
  type HruSettings,
} from "../types";

import type { TimelineScheduler } from "../services/timelineScheduler";
import type { HruService } from "../features/hru/hru.service";
import { validateRequest } from "../middleware/validateRequest";
import {
  timelineModeInputSchema,
  timelineEventInputSchema,
  boostOverrideInputSchema,
  type TimelineModeInput,
  type TimelineEventInput,
} from "../schemas/timeline";

export function createTimelineRouter(
  logger: Logger,
  timelineScheduler: TimelineScheduler,
  hruService: HruService,
) {
  const router = Router();

  function getCurrentUnitId(unitIdOverride?: string): string | null {
    try {
      if (unitIdOverride) return unitIdOverride;

      const raw = getAppSetting(HRU_SETTINGS_KEY);
      const settings = raw ? (JSON.parse(raw) as HruSettings) : null;
      if (settings?.unit) return settings.unit;

      // Fallback to first available unit if none selected, matches frontend fallback
      const units = hruService.getAllUnits();
      return units[0]?.id || null;
    } catch {
      return null;
    }
  }

  function getHruMaxPower(): number {
    try {
      // Get current HRU settings to find which unit is selected
      const settingsRaw = getAppSetting(HRU_SETTINGS_KEY);
      if (!settingsRaw) {
        logger.warn("No HRU settings found, using default max power 100");
        return 100;
      }

      const settings = JSON.parse(String(settingsRaw)) as HruSettings;
      const unitId = settings.unit;

      if (!unitId) {
        logger.warn("No unit ID in HRU settings, using default max power 100");
        return 100;
      }

      // Get the unit definition from HRU service
      const units = hruService.getAllUnits();
      const currentUnit = units.find((u) => u.id === unitId);

      if (!currentUnit) {
        logger.warn({ unitId }, "Unit not found in HRU service, using default max power 100");
        return 100;
      }

      // Use maxPower override if unit is configurable, otherwise use unit's maxValue
      const maxPower =
        currentUnit.isConfigurable && settings.maxPower
          ? settings.maxPower
          : currentUnit.maxValue || 100;

      logger.info(
        {
          unitId,
          unitMaxValue: currentUnit.maxValue,
          settingsMaxPower: settings.maxPower,
          isConfigurable: currentUnit.isConfigurable,
          finalMaxPower: maxPower,
        },
        "Retrieved HRU max power for validation",
      );

      return maxPower;
    } catch (error) {
      logger.warn({ error }, "Failed to get HRU max power, using default");
      return 100;
    }
  }

  function validatePowerAndValves(payload: TimelineModeInput, response: Response): boolean {
    const maxPower = getHruMaxPower();

    logger.info(
      { maxPower, payloadPower: payload.power, valves: payload.luftatorConfig },
      "Validating timeline mode power and valves",
    );

    if (payload.power !== undefined && payload.power > maxPower) {
      response.status(400).json({
        detail: `Power must be between 0 and ${maxPower}`,
      });
      return false;
    }

    return true;
  }

  router.get("/modes", (request: Request, response: Response) => {
    const currentUnitId = getCurrentUnitId(request.query.unitId as string) || "";
    // Pass unit ID to DB fetching so we get global AND unit specific modes
    const allModes = getTimelineModes(currentUnitId);

    // Migration logic removed from GET - migration is now handled by DB service on startup
    // We just return filtered modes
    const filteredModes = allModes.filter((m) => m.hruId === currentUnitId || !m.hruId);
    response.json({ modes: filteredModes });
  });

  router.post(
    "/modes",
    validateRequest(timelineModeInputSchema),
    (request: Request, response: Response) => {
      const payload = request.body as TimelineModeInput;
      const currentUnitId = getCurrentUnitId();

      // Validate against HRU max power
      if (!validatePowerAndValves(payload, response)) {
        return;
      }

      try {
        const newMode: TimelineMode = {
          // ID is auto-generated by DB if creating
          id: 0, // Placeholder, DB ignores/overwrites
          name: payload.name,
          color: payload.color,
          power: payload.power,
          temperature: payload.temperature,
          luftatorConfig: payload.luftatorConfig,
          isBoost: payload.isBoost ?? false,
          hruId: currentUnitId || "",
          nativeMode: payload.nativeMode,
        };

        // We need to pass undefined ID for creation, but type expects number.
        // upsertTimelineMode handles null/undefined ID for creation logic.
        const created = upsertTimelineMode({ ...newMode, id: undefined as unknown as number });
        response.status(201).json(created);
      } catch (err) {
        if (err instanceof Error && err.message.includes("UNIQUE constraint failed")) {
          response.status(409).json({ detail: "Mode name already exists for this unit" });
          return;
        }
        logger.error({ err }, "Failed to create timeline mode");
        response.status(500).json({ detail: "Failed to create mode" });
      }
    },
  );

  router.put(
    "/modes/:id",
    validateRequest(timelineModeInputSchema),
    (request: Request, response: Response) => {
      const id = Number.parseInt(request.params.id as string, 10);
      if (!Number.isFinite(id)) {
        response.status(400).json({ detail: "Invalid mode id" });
        return;
      }
      const payload = request.body as TimelineModeInput;

      // Validate against HRU max power
      if (!validatePowerAndValves(payload, response)) {
        return;
      }

      try {
        const original = getTimelineMode(id);
        if (!original) {
          response.status(404).json({ detail: "Mode not found" });
          return;
        }

        const updated: TimelineMode = {
          id: id,
          name: payload.name,
          color: payload.color,
          power: payload.power,
          temperature: payload.temperature,
          luftatorConfig: payload.luftatorConfig,
          isBoost: payload.isBoost ?? false,
          hruId: original.hruId || getCurrentUnitId() || "",
          nativeMode: payload.nativeMode,
        };

        const saved = upsertTimelineMode(updated);
        response.json(saved);
      } catch (err) {
        if (err instanceof Error && err.message.includes("UNIQUE constraint failed")) {
          response.status(409).json({ detail: "Mode name already exists for this unit" });
          return;
        }
        logger.error({ err, id }, "Failed to update timeline mode");
        response.status(500).json({ detail: "Failed to update mode" });
      }
    },
  );

  router.delete("/modes/:id", (request: Request, response: Response) => {
    const id = Number.parseInt(request.params.id as string, 10);
    if (!Number.isFinite(id)) {
      response.status(400).json({ detail: "Invalid mode id" });
      return;
    }

    try {
      // Cascade: delete events using this mode
      deleteTimelineEventsByMode(id);
    } catch (err) {
      logger.error({ err, id }, "Failed to delete associated timeline events");
    }

    // Cascade: clear boost if it uses this mode
    try {
      const rawOverride = getAppSetting(TIMELINE_OVERRIDE_KEY);
      if (rawOverride && rawOverride !== "null") {
        const override = JSON.parse(rawOverride) as TimelineOverride;
        if (override?.modeId === id) {
          setAppSetting(TIMELINE_OVERRIDE_KEY, "null");
          logger.info({ id }, "Cleared active boost because its mode was deleted");
        }
      }
    } catch (err) {
      logger.warn({ err }, "Failed to check/clear boost during mode deletion");
    }

    try {
      deleteTimelineMode(id);
      response.status(204).end();
    } catch (err) {
      logger.error({ err, id }, "Failed to delete timeline mode");
      response.status(500).json({ detail: "Failed to delete mode" });
    }
  });

  // Timeline Events
  router.get("/events", (request: Request, response: Response) => {
    try {
      const hruId = getCurrentUnitId(request.query.unitId as string);
      if (hruId) {
        // Adopt legacy events if any exist (lazy migration)
        try {
          assignLegacyEventsToUnit(hruId);
        } catch (err) {
          logger.warn({ err }, "Failed to assign legacy events during fetch");
        }
      }

      const events = getTimelineEvents(hruId);

      // Self-healing: purge orphaned events (referencing non-existent modes)
      const modes = getTimelineModes(hruId || undefined);
      const modeIds = new Set(modes.map((m) => m.id));
      const orphanedIds = events
        .filter((e) => {
          const hruConfig = e.hruConfig as { mode?: number | string } | null;
          const modeId = hruConfig?.mode;
          if (modeId === undefined) return false;
          return !modeIds.has(Number(modeId));
        })
        .map((e) => e.id)
        .filter((id): id is number => typeof id === "number");

      if (orphanedIds.length > 0) {
        logger.info({ count: orphanedIds.length }, "Purging orphaned timeline events");
        for (const id of orphanedIds) {
          try {
            deleteTimelineEvent(id);
          } catch (err) {
            logger.warn({ err, id }, "Failed to purge orphaned event");
          }
        }
        // Return filtered list to UI immediately
        const orphanSet = new Set(orphanedIds);
        response.json(events.filter((e) => e.id === undefined || !orphanSet.has(e.id)));
      } else {
        response.json(events);
      }
    } catch (error) {
      logger.warn({ error }, "Failed to get timeline events");
      response.status(500).json({ detail: "Failed to retrieve timeline events" });
    }
  });

  router.post(
    "/events",
    validateRequest(timelineEventInputSchema),
    (request: Request, response: Response) => {
      const body = request.body as TimelineEventInput;

      // Validate HRU config against max power
      const maxPower = getHruMaxPower();
      if (body.hruConfig?.power !== undefined && body.hruConfig.power > maxPower) {
        response.status(400).json({
          detail: `Power must be between 0 and ${maxPower}`,
        });
        return;
      }

      try {
        const hruId = getCurrentUnitId(request.query.unitId as string);
        const event = upsertTimelineEvent({
          id: body.id,
          startTime: body.startTime,
          dayOfWeek: body.dayOfWeek,
          hruConfig: body.hruConfig,
          luftatorConfig: body.luftatorConfig,
          enabled: body.enabled ?? true,
          priority: body.priority ?? 0,
          hruId: hruId,
        });
        response.json(event);
      } catch (error) {
        logger.warn({ error }, "Failed to save timeline event");
        response.status(500).json({ detail: "Failed to save timeline event" });
      }
    },
  );

  router.delete("/events/:id", (request: Request, response: Response) => {
    const id = Number.parseInt(request.params.id as string, 10);
    if (!Number.isFinite(id)) {
      response.status(400).json({ detail: "Invalid event ID" });
      return;
    }

    try {
      deleteTimelineEvent(id);
      response.status(204).end();
    } catch (error) {
      logger.warn({ error, id }, "Failed to delete timeline event");
      response.status(500).json({ detail: "Failed to delete timeline event" });
    }
  });

  // Boost Overrides
  router.get("/boost", (_request: Request, response: Response) => {
    const raw = getAppSetting(TIMELINE_OVERRIDE_KEY);
    if (!raw) return response.json({ active: null });
    try {
      const parsed = JSON.parse(raw) as TimelineOverride;
      // Filter out expired boosts
      if (parsed && new Date(parsed.endTime) < new Date()) {
        setAppSetting(TIMELINE_OVERRIDE_KEY, "null");
        return response.json({ active: null });
      }
      response.json({ active: parsed });
    } catch {
      response.json({ active: null });
    }
  });

  router.post(
    "/boost",
    validateRequest(boostOverrideInputSchema),
    async (request: Request, response: Response) => {
      const { modeId, durationMinutes } = request.body as {
        modeId: number;
        durationMinutes: number;
      };

      const unitId = request.query.unitId as string | undefined;
      const hruId = getCurrentUnitId(unitId);

      const modes = getTimelineModes(hruId || undefined);
      const mode = modes.find((m) => m.id === modeId);
      if (!mode) return response.status(404).json({ detail: "Mode not found" });

      const endTime = new Date(Date.now() + durationMinutes * 60 * 1000).toISOString();
      const override: TimelineOverride = { modeId, endTime, durationMinutes };

      setAppSetting(TIMELINE_OVERRIDE_KEY, JSON.stringify(override));
      logger.info({ modeId, durationMinutes, endTime }, "Timeline boost activated");

      // Trigger immediate execution
      await timelineScheduler.executeScheduledEvent();

      response.json({ active: override });
    },
  );

  router.delete("/boost", async (_request: Request, response: Response) => {
    setAppSetting(TIMELINE_OVERRIDE_KEY, "null");
    logger.info("Timeline boost cancelled");

    // Trigger immediate execution
    await timelineScheduler.executeScheduledEvent();

    response.status(204).end();
  });

  return router;
}
